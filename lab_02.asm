.586P   ; указываем транслятору на расширенный набор команд 32х разраядного процессора
;
;описание структуры дескриптора сегмента 
; в реальном режиме сегменты определяются их базовыми адресами - 16 битные 
; в защищенном - 8мибайтовым дескриптором 
descr struc 
	lim dw 0 ; номер последнего байта сегмента размер сегмента в байтах (байты 0-1)
; (!) Если граница указывается в байтах, то макс. размер сегмента 1Мб
; (!) Если граница указывается в блоках по 4Кб, то макс. размер сегмента - 4Гб	
; В каких единицах указывается граница определяет старший бит атрибута 2 (БИТ ДРОБНОСТИ)
; база сегмента (23 ... 0) байты (2 - 4)
    base_l dw 0 ; Младшие 16 битов адресной базы. - базовый адрес задаётся в виртуальном адресном пространстве (байты 2-3)
	base_m db 0 ; следюущие 8 битов -//- (байт 4)
	attr_1 db 0 ; флаги/атрибуты доступа, определяющие в каком кольце защиты (байт 5)
	attr_2 db 0 ; можно использовать этот сегмент. (байт 6)
	base_h db 0 ; Последние 8 битов адресной базы. (байт 7 31...24)
descr ends
; Линейный адрес == номер байта в адресном пространстве 
; в реал. режиме == номер байта в физ. адресном пространстве 
; в защ. режиме == номер байта в ВИРТУАЛЬНОМ адр простр.
;
; В защ. режиме для обращения к требуемому сегменту
; в сегментый регистр надо занести не базовый адрес сегмента
; а селектор дескриптора (в состав которого входит номер соотвествующего дескриптора)
data SEGMENT USE16 ; объявляет, что в данном сегменте будут по умолчанию использоваться 16-битовые адреса и операнды. 
    ; Таблица глобальных дескрипторов
	gdt_null descr <0, 0, 0, 0, 0, 0> ; селектор 0, нулевой дескриптор 
	gdt_data descr <data_size - 1, 0, 0, 10010010b, 0, 0> ; селектор 8, дескриптор сегмента данных
	gdt_code descr <code_size - 1, 0, 0, 10011000b, 0, 0> ; селектор 16, дескриптор сегмента команд
	gdt_stack descr <255, 0, 0, 92h, 0, 0> ; селектор 24 - сегмента кода 
	gdt_screen descr <3999, 8000h, 0Bh, 92h, 0, 0> ; селектор 32 - видеопамять(размещается в первом мегабайте пространсвта)
	gdt_size=$-gdt_null
    pdescr df 0
	attr   db 1Eh
	msg1 db 27, '[21;32m In Real Mode! ',10, 27, '[0m$' 
    msg db 27, '[21;32m In Real Mode again! ', 27, '[0m$'
	data_size=$-gdt_null ;размер GDT
data ends

text SEGMENT USE16
    assume CS:text, DS:data
main proc
    xor eax, eax
    mov ax, data
    mov ds, ax ; загружаем ds сегментный адрес сегмента данных 

    ; вычисляем 32битный линейный адрес сегмента данных
    ; загружаем его в дескриптор сегмента данных в таблице GDT
    shl eax, 4 ;Сдвинем влево eax на 4 бита(умножение на 16)  Теперь в DL:EAX 32х битный линейный алрес сегмента (потому что выравнивание по параграфу)данных  
    mov ebp, eax
    mov bx, offset gdt_data ; в bx загружается смещение дескриптора сегмента данных
;	assume bx:ptr descr 
    mov [bx].base_l, ax ; в дескриптор из ax заносится младшая половина линейного адреса
    shr eax, 16 ; так как к старшей части региста eax обратиться невозможно с помощью команды shr сдвигаем вправо
    mov [bx].base_m, al ; записываем без ah потому что там и так нули
    ;
    xor eax, eax
    mov ax, CS ; загружаем ax сегментный адрес сегмента команд
    ; вычисляем и загружаем в GDT линейный адрес сегмента команд 
    shl eax, 4
    mov bx, offset gdt_code
    mov [bx].base_l, ax
    shr eax, 16
    mov [bx].base_m, al
    ;
    xor eax, eax
    mov ax, SS ; загружаем ax сегментный адрес сегмента команд
    ; вычисляем и загружаем в GDT линейный адрес сегмента стека
    shl eax, 4
    mov bx, offset gdt_stack
    mov [bx].base_l, ax
    shr eax, 16
    mov [bx].base_m, al
    ; 
    mov ah, 09h
    mov dx, offset msg1
    int 21h
    ;
    mov dword ptr pdescr+2, ebp ; база GDT  (байты 2-5) 
    mov word ptr pdescr, gdt_size-1 ; граница GDT (байты 0, 1) 
    lgdt pdescr ; загружает регистр GDTR и сообщает процессору о местонахождении и размере GDT
   ; в ячейку 40h:67h запишем адрес возврата, в байт Fh занесём код Ah.
	mov ax, 40h 
    mov es, ax ; настроим es на область данных bios
    mov word ptr es:[67h], offset return ; смещение возврата 
    mov es:[69h], cs                     ; сегмент возврата
    mov al, 0Fh ;Адрес байта состояния отключения
	out 70h, al ;порт КМОП -микросхемы
    mov al, 0Ah ; возврат в реальный режим с помощью jump far[40:67] по команде сброса  (код байта по адресу Fh)
    out 71h, al 
    cli ; запрет аппаратных прерываний 
;
; (!!!) TO PROTECTED MODE HERE (!!!)
    mov eax, cr0 ; получаем содержимое регистра CR0 управляющий регистр процессора(доступны только в защ. режиме для програм с уровнем привилегий 0
    or eax, 1    ; установка бита защищенного режима установка бита PM
    mov cr0, eax ; сохранение содержимого в CR0
;
; PROCESSOR'S RUNNING IN PROTECTED MODE
; загружаем в CS:IP селектор:смещение точки continue 
    db 0EAh  ; код команды far jump
    dw offset continue
    dw 16 ; селектор сегмента команд защищенного режима 
continue:
;Делаем адресуемыми данные
    mov ax, 8 ; селектор сегмента данных защищенного режима
    mov ds, ax
;
    mov ax, 24 ; селектор сегмента стека защищенного режима
    mov ss, ax
;
    mov ax, 32 ; селектор сегмента видеобуфера
    mov es, ax
; Вывод на экран строки символов
; так как в защищенном режиме мы не можем использовать 
; команды DOS, то вывод строки осуществляется посимвольно
    mov DI, 2500 ; положение
    mov ah, 00000010b ;атрибуты
    mov al, 'P'
    stosw ; отправляет значение al в DI после завершения пересылки индексная часть увеличивается
    mov al, 'r'
    stosw
    mov al, 'o'
    stosw
    mov al, 't'
    stosw
    mov al, 'e'
    stosw
    mov al, 'c'
    stosw
    mov al, 't'
    stosw
    mov al, 'e'
    stosw
    mov al, 'd'
    stosw
    mov al, ' '
    stosw
    mov al, 'M'
    stosw
    mov al, 'o'
    stosw
    mov al, 'd'
    stosw
    mov al, 'e'
    stosw
;
; BACK TO REAL MODE
;
; 
    mov gdt_data.lim, 0FFFFh  ; граница сегмента данных
    mov gdt_code.lim, 0FFFFh  ; граница сегмента команд
    mov gdt_stack.lim, 0FFFFh ; граница сегмента стека
    mov gdt_screen.lim, 0FFFFh ; граница сегмента видеобуфера
	;
    push DS ; 
    pop DS
    push SS
    pop SS
    push ES
    pop ES
; 
    db 0EAh 
    dw offset go 
    dw 16 ; селектор сегмента кода
; переход в реальный режим 
go: 
    mov eax, cr0
    and eax,  0FFFFFFFEh ; сброс бита защищенного режима
    mov cr0, eax
    db 0EAh
    dw offset return
    dw text ; сегмент кода в реальном режиме
; PROCESSOR'S RUNNING IN REAL MODE
return:
    mov ax, data
    mov ds, ax
    mov ax, stk
    mov SS, ax 
    sti ; разрешение аппаратных прерываний
; 
    mov ah, 09h
    mov dx, offset msg
    int 21h ; вывод строки
    mov ax, 4C00h
    int 21h
main endp
code_size=$-main 
text ends 
;
stk segment stack use16
    db 256 dup ('^')
stk ends
    end main