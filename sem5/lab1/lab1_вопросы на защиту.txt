в: Почему перед сбросом контроллера прервывания нужно запретить маскирование прерывания?
   для чего сбрасывается контроллер прервывания?
о: сброс контроллера разрешает выполнение прервывания

в: Как доказать что по адресу 0040 006с inc word ptr ds:[6ch] находится счетчик реального времени? (непонятно на основе 16ричного кода)
о: 

в:  Как по научному называются 4 push в конце прерывания?
о:  Сохранение аппаратного контекста

в: Как получили адрес обработчика прерывания?
о: Таблица векторов прерываний (IDT) в DOS расположена по нулевому адресу. 
   Зная номер прерывания, можно получить смещение в этой таблице, по которому расположен дальний (far) адрес обработчика прерывания. 
   Размер дальнего адреса - 4 байта (2 на сегмент и 2 на смещение). Например, для 8 прерывания смещение = 8 * 4 = 32. 
   Надо иметь в виду, что в x86 используется обратный порядок записи байтов (little endian), 
   поэтому если таблица векторов прерываний получена в виде массива байтов, 
   то для получения шестнадцатеричного адреса необходимо перевернуть расположенные по найденному смещению 4 байта.

в: Как называется такое действие в системе как отключение моторчика дисковода?
о: Отложенное действие. потому что диску требуется время. приводит к временным затратам.

в: Как получить реальное время, если известен адрес, по которому хранится число тиков с момента старта системы?
о: Поделить число тиков на 18.2 - получим время в миллисекундах. (делим на 1000 получаем секунды, делим на 60 получаем минуты, в другой ячейке у нас часы)

в: Как называется эта команда (показывает на вызов обработчика прерывания 1Ch по адресу из IDT: call dword ptr es:[70h])
о: Косвенный вызов.

в: Что находится внутри обработчика прерывания 1Ch?
о: Это заглушка, внутри просто iret.

в: Зачем ведется отсчет времени до отключения моторчика дисковода?
о: Операции ввода-вывода идут последовательно, поэтому моторчик включен в течении 2 секунд, чтобы не раскручивать его заново. 
   (ругается на то, что у нас не всегда идут операции ввода/вывода последовательно. Спрашивает, когда мы последовательно читаем  – когда читаем массив, например. )

в: Зачем нужно прерывание 1Ch, если есть 8h?
о: 1Ch – программное прерывание, а 8h — аппаратное. Если менять аппаратное прерывание может произойти сбой.

-------
в: Почему в коде декремента счетчика задержки отключения моторчика дисковода нет проверки, что в счетчике 0?
о: Чтобы не выполнять лишние операции (для быстродействия)

в: Что такое маскируемые и не маскируемые прерывания?
о: Маскируемые вызываются по маске - соответственно вызов таких прерываний можно запретить. Не маскируемые запретить нельзя, 
   такими могут быть ошибки различные

в: По какой шине передается маска маскируемого прерывания? 
о: По шине данных, так как маска является данным

в: что значит каждая из колонок листинга?
о: (слева - направо) адреса (сегмент-смещение!), машинный код, команды ассемблера, комментарии

в: Что за флаг IF?
о: Interrapt flag - флаг прерывания - 1=разрешено, 0=запрещено

в: Зачем сохраняем флаги в AH? (команда lahf)
о: Тк регистор флагов не доступен, сохраняем флаги в AH, выполняем какие-то операции, возможно меняющие флаги, восстанавливаем флаги (sahf)

------------
в: Зачем ведется отсчет времени до отключения моторчика дисковода? (upd)
о: Операции ввода-вывода идут последовательно, поэтому моторчик включен в течении 2 секунд, чтобы не раскручивать его заново. 
   (ругается на то, что у нас не всегда идут операции ввода/вывода последовательно. Чтобы не тратить время на раскрутку моторчика.
    Спрашивает, когда мы последовательно читаем  – когда читаем массив, например. )

в: Зачем нужно прерывание 1Ch, если есть 8h?
о: 1Ch – программное прерывание, а 8h — аппаратное. Если изменять код аппаратного, оно будет выполняться долго, 
   а так как в doc у int8h самый высокий приоритет, то все процессорное время будет занято выполнением кода int8h

в: что это за адрес - 0040:0314h ?
о: область данных биос
- там содержится копия флагов

в: 10ый бит по этому адресу - копия interrupt flag IF
-------------
в: что делает префиксная команда lock?
о: указывает на то, что следующее за ней команда должна выполняться, как неделимая. Прервать выполнение след за lock команды нельзя.
Технически это осуществляется блокировкой локальной шины памяти. На время выполнения команды блокируется локальная шина памяти.

Useful tips:

На схеме конец процедуры должен быть представлен исключительно в виде скругленного прямоугольника (или овала) со словом "конец". 
То есть, варианты типа "возврат из обработчика прерывания" не подходят.

Для тех, кто будет рефакторить сами-знаете-чьи отчеты: "Отправка в порт 3F2h (порт управления дисководом) команды 0Ch (команда остановки)" не годится.
Я не помню точную формулировку, которая ей подходит, но нужно примерно так: "передача контроллеру дисковода команды 0Ch В порт 3F2h на остановку моторчика".

- Писать не блок-схема, а просто схема, иначе лекцию про блоки прослушаете
- Не писать - сохранение/восстановление аппаратного контекста в начале/конце обработчика - писать нужно конкретные регистры
- Разрыв на блок схеме - только кружочек


Почему lock ставится перед and и не ставится перед test?
Собственно lock ставится перед and потому что мы в память лезем два раза и надо чтоб в этот момент передача данных по локальной шине была заблокирована чтоб ничего не полетело
А перед test не старится потому что оно в память не лезет
Не пишет ничего никуда